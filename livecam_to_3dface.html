<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <!-- Include necessary libraries -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <script src="facemesh.js"></script>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
          "imports": {
            "three": "https://unpkg.com/three@v0.152.2/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@<0.152.2/examples/jsm/"
          }
        }
    </script>
</head>

<body>
    <div class="container">
        <video class="input_video"></video>
        <canvas class="output_canvas" width="800px" height="450px"></canvas>
    </div>
    <div class="container">
        <div style="text-align: center;">
            <div id="threejs"></div>
        </div>
    
    <script type="module">
        // Import necessary modules
        import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.118/build/three.module.js";
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.118/examples/jsm/controls/OrbitControls.js';
        import { OBJLoader } from "https://cdn.jsdelivr.net/npm/three@0.118/examples/jsm/loaders/OBJLoader.js";
        import { BufferGeometryUtils } from 'https://cdn.jsdelivr.net/npm/three@0.118/examples/jsm/utils/BufferGeometryUtils.js';

        // Get the video and canvas elements
        const videoElement = document.getElementsByClassName('input_video')[0];
        const canvasElement = document.getElementsByClassName('output_canvas')[0];
        const canvasCtx = canvasElement.getContext('2d');

        function onResults(results) {
            let landmarks = null;
            if (results.multiFaceLandmarks) {
                for (const lm of results.multiFaceLandmarks) {
                    landmarks = lm;
                }
            }

            if (landmarks === null) {
                alert("Face landmarks not detected");
                return;
            }

            // Destroy previous scene canvas, if any
            let elem = document.getElementById("threejs");
            while (elem.lastChild) {
                elem.removeChild(elem.lastChild);
            }

            // Create the scene
            const scene = new THREE.Scene();

            // Create the renderer
            const renderer = new THREE.WebGLRenderer();
            renderer.setSize(500, 500);
            document.getElementById("threejs").appendChild(renderer.domElement);

            // Create a geometry object
            var geometry = new THREE.Geometry();

            // Add vertices to the geometry
            for (var i = 0; i < landmarks.length; i++) {
                var vertex = new THREE.Vector3(landmarks[i].x, -landmarks[i].y, -landmarks[i].z);
                // Map the landmarks to three.js coordinate system (y and z values are negated)
                geometry.vertices.push(vertex);
            }

            // Add faces to the geometry using the indices
         
            for (var i = 0; i < FACEMESH.length; i += 3) {
                var face = new THREE.Face3(FACEMESH[i], FACEMESH[i + 1], FACEMESH[i + 2]);
                geometry.faces.push(face);
            }

            // Compute face normals and vertex normals for smooth shading
            geometry.computeFaceNormals();
            geometry.computeVertexNormals();

            const material = new THREE.MeshPhongMaterial({ color: 0xffddcc, side: THREE.DoubleSide });

            // Create a mesh using the geometry and material
            var mesh = new THREE.Mesh(geometry, material);

            // Add the mesh to the scene
            scene.add(mesh);

            mesh.geometry.computeBoundingSphere();

            // Create the camera
            const camera = new THREE.PerspectiveCamera(30, canvasElement.clientHeight / canvasElement.clientWidth, 0.1, 1000);
            camera.position.x = mesh.geometry.boundingSphere.center.x;
            camera.position.y = mesh.geometry.boundingSphere.center.y;
            camera.position.z = 2;

            // Create the OrbitControls for camera movement
            const controls = new OrbitControls(camera, renderer.domElement);
            controls.autoRotate = true;
            controls.target = mesh.geometry.boundingSphere.center;

            // Add hemisphere light for simulating sky light
            const light = new THREE.HemisphereLight(0xffffff, 0x0000ff, 1);
            light.position.set(0, 0, 20);
            scene.add(light);

            // Animation function to update and render the scene continuously
            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }

            animate();
        }

        const faceMesh = new FaceMesh({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
            }
        });
        faceMesh.setOptions({
            maxNumFaces: 1,
            refineLandmarks: true,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        faceMesh.onResults(onResults);

        const camera = new Camera(videoElement, {
            onFrame: async () => {
                await faceMesh.send({ image: videoElement });
            },
            width: 800,
            height: 450
        });
        camera.start();
    </script>
</body>

</html>